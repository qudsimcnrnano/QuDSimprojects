#!/usr/bin/env python3
"""
plot_scaling.py - Scaling Analysis Plots for GAA Nanowire FET Simulator

Reads scaling_data.csv generated by the simulation timer (QDSimTimer)
and produces:
  1. Speedup plot (actual vs ideal)
  2. Parallel efficiency plot
  3. Timing breakdown (stacked bar chart per phase)
  4. Per-phase scaling lines

Usage:
  python3 plot_scaling.py                          # Default: reads scaling_data.csv
  python3 plot_scaling.py --input my_data.csv      # Custom input file
  python3 plot_scaling.py --output results/         # Custom output directory
"""

import argparse
import os
import sys
import csv
import numpy as np

try:
    import matplotlib
    matplotlib.use('Agg')  # Non-interactive backend for cluster use
    import matplotlib.pyplot as plt
    from matplotlib.ticker import MaxNLocator
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False
    print("WARNING: matplotlib not found. Will generate text-only summary.")


def read_scaling_data(filename):
    """Read the CSV scaling data file."""
    data = {}
    phases = []

    with open(filename, 'r') as f:
        reader = csv.DictReader(f)
        phases = [col for col in reader.fieldnames if col not in ('nprocs', 'total_wall_time')]

        for row in reader:
            np_val = int(row['nprocs'])
            data[np_val] = {
                'total': float(row['total_wall_time']),
            }
            for phase in phases:
                data[np_val][phase] = float(row[phase])

    # Sort by core count
    sorted_nprocs = sorted(data.keys())
    return sorted_nprocs, phases, data


def compute_scaling_metrics(nprocs_list, data):
    """Compute speedup and efficiency from timing data."""
    t1 = data[nprocs_list[0]]['total']  # baseline (smallest core count)
    base_np = nprocs_list[0]

    speedup = []
    efficiency = []

    for np_val in nprocs_list:
        s = t1 / data[np_val]['total']
        e = s / (np_val / base_np)
        speedup.append(s)
        efficiency.append(e * 100)  # as percentage

    return speedup, efficiency


def print_text_summary(nprocs_list, phases, data, speedup, efficiency):
    """Print text-based scaling summary."""
    print("\n" + "=" * 80)
    print("  SCALING ANALYSIS - GAA Nanowire FET Parallel Simulator")
    print("=" * 80)

    # Main table
    header = f"{'Cores':>6} {'Total(s)':>10} {'Speedup':>9} {'Eff(%)':>8}"
    for phase in phases:
        short_name = phase[:12]
        header += f" {short_name:>12}"
    print(header)
    print("-" * len(header))

    for i, np_val in enumerate(nprocs_list):
        line = f"{np_val:>6} {data[np_val]['total']:>10.4f} {speedup[i]:>9.2f} {efficiency[i]:>7.1f}%"
        for phase in phases:
            line += f" {data[np_val][phase]:>12.4f}"
        print(line)

    print("-" * len(header))

    # Highlight best speedup
    best_idx = np.argmax(speedup)
    print(f"\nBest speedup: {speedup[best_idx]:.2f}x with {nprocs_list[best_idx]} cores")
    print(f"Best efficiency: {max(efficiency):.1f}% with {nprocs_list[np.argmax(efficiency)]} cores")

    # Amdahl's law estimate
    if len(nprocs_list) > 1 and speedup[-1] > 1:
        # Estimate serial fraction from last data point
        s_n = speedup[-1]
        n = nprocs_list[-1] / nprocs_list[0]
        f_serial = (1 / s_n - 1 / n) / (1 - 1 / n) if n > 1 else 0
        f_serial = max(0, min(1, f_serial))
        print(f"\nEstimated serial fraction (Amdahl): {f_serial:.3f} ({f_serial*100:.1f}%)")
        max_theoretical = 1.0 / f_serial if f_serial > 0 else float('inf')
        print(f"Theoretical max speedup (Amdahl):   {max_theoretical:.1f}x")

    print("=" * 80 + "\n")


def plot_scaling(nprocs_list, phases, data, speedup, efficiency, output_dir):
    """Generate all scaling plots."""

    os.makedirs(output_dir, exist_ok=True)
    np_arr = np.array(nprocs_list)

    # Color scheme
    colors = ['#2196F3', '#4CAF50', '#FF9800', '#F44336', '#9C27B0',
              '#00BCD4', '#795548', '#607D8B', '#E91E63', '#3F51B5']

    # =================== Plot 1: Speedup ===================================
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))

    ideal_speedup = np_arr / nprocs_list[0]
    ax.plot(np_arr, speedup, 'o-', color='#2196F3', linewidth=2.5,
            markersize=8, label='Measured Speedup', zorder=5)
    ax.plot(np_arr, ideal_speedup, 'k--', linewidth=1.5, alpha=0.5,
            label='Ideal (Linear) Speedup')

    ax.set_xlabel('Number of MPI Processes', fontsize=13)
    ax.set_ylabel('Speedup', fontsize=13)
    ax.set_title('Strong Scaling: Speedup\nGAA Nanowire FET Simulator', fontsize=14)
    ax.legend(fontsize=11, loc='upper left')
    ax.grid(True, alpha=0.3)
    ax.xaxis.set_major_locator(MaxNLocator(integer=True))
    ax.set_xlim(left=0)
    ax.set_ylim(bottom=0)

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'speedup.png'), dpi=150)
    plt.close()

    # =================== Plot 2: Efficiency ================================
    fig, ax = plt.subplots(1, 1, figsize=(8, 6))

    ax.plot(np_arr, efficiency, 'o-', color='#4CAF50', linewidth=2.5,
            markersize=8, label='Parallel Efficiency')
    ax.axhline(y=100, color='k', linestyle='--', linewidth=1.5, alpha=0.5,
               label='Ideal (100%)')
    ax.axhline(y=80, color='orange', linestyle=':', linewidth=1, alpha=0.5,
               label='80% threshold')

    ax.set_xlabel('Number of MPI Processes', fontsize=13)
    ax.set_ylabel('Parallel Efficiency (%)', fontsize=13)
    ax.set_title('Strong Scaling: Parallel Efficiency\nGAA Nanowire FET Simulator', fontsize=14)
    ax.legend(fontsize=11, loc='upper right')
    ax.grid(True, alpha=0.3)
    ax.xaxis.set_major_locator(MaxNLocator(integer=True))
    ax.set_xlim(left=0)
    ax.set_ylim(0, 110)

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'efficiency.png'), dpi=150)
    plt.close()

    # =================== Plot 3: Timing Breakdown ==========================
    fig, ax = plt.subplots(1, 1, figsize=(10, 6))

    x = np.arange(len(nprocs_list))
    width = 0.6
    bottoms = np.zeros(len(nprocs_list))

    for pi, phase in enumerate(phases):
        values = [data[np_val][phase] for np_val in nprocs_list]
        color = colors[pi % len(colors)]
        ax.bar(x, values, width, bottom=bottoms, label=phase, color=color, alpha=0.85)
        bottoms += np.array(values)

    ax.set_xlabel('Number of MPI Processes', fontsize=13)
    ax.set_ylabel('Time (seconds)', fontsize=13)
    ax.set_title('Timing Breakdown by Phase\nGAA Nanowire FET Simulator', fontsize=14)
    ax.set_xticks(x)
    ax.set_xticklabels([str(n) for n in nprocs_list])
    ax.legend(fontsize=9, loc='upper right', ncol=2)
    ax.grid(True, alpha=0.3, axis='y')

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'timing_breakdown.png'), dpi=150)
    plt.close()

    # =================== Plot 4: Per-Phase Scaling =========================
    fig, ax = plt.subplots(1, 1, figsize=(10, 6))

    for pi, phase in enumerate(phases):
        values = [data[np_val][phase] for np_val in nprocs_list]
        if max(values) > 0.001:  # Only plot phases with measurable time
            color = colors[pi % len(colors)]
            ax.plot(np_arr, values, 'o-', color=color, linewidth=2,
                    markersize=6, label=phase)

    # Total
    total_values = [data[np_val]['total'] for np_val in nprocs_list]
    ax.plot(np_arr, total_values, 's-', color='black', linewidth=2.5,
            markersize=8, label='Total', zorder=10)

    ax.set_xlabel('Number of MPI Processes', fontsize=13)
    ax.set_ylabel('Time (seconds)', fontsize=13)
    ax.set_title('Per-Phase Scaling\nGAA Nanowire FET Simulator', fontsize=14)
    ax.legend(fontsize=9, loc='upper right', ncol=2)
    ax.grid(True, alpha=0.3)
    ax.xaxis.set_major_locator(MaxNLocator(integer=True))
    ax.set_xlim(left=0)

    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'phase_scaling.png'), dpi=150)
    plt.close()

    # =================== Plot 5: Pie chart (largest core count) =============
    fig, axes = plt.subplots(1, 2, figsize=(14, 6))

    for idx, (ax, np_val) in enumerate(zip(axes, [nprocs_list[0], nprocs_list[-1]])):
        values = [data[np_val][phase] for phase in phases]
        labels = phases
        # Filter out tiny slices
        total = sum(values)
        filtered = [(v, l) for v, l in zip(values, labels) if v / total > 0.01]
        if filtered:
            vals, labs = zip(*filtered)
        else:
            vals, labs = values, labels

        pie_colors = [colors[i % len(colors)] for i in range(len(vals))]
        ax.pie(vals, labels=labs, autopct='%1.1f%%', colors=pie_colors,
               startangle=90, textprops={'fontsize': 9})
        ax.set_title(f'Time Distribution ({np_val} core{"s" if np_val>1 else ""})',
                     fontsize=12)

    plt.suptitle('GAA Nanowire FET - Time Distribution', fontsize=14)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'time_distribution.png'), dpi=150)
    plt.close()

    print(f"Plots saved to {output_dir}/:")
    print(f"  - speedup.png")
    print(f"  - efficiency.png")
    print(f"  - timing_breakdown.png")
    print(f"  - phase_scaling.png")
    print(f"  - time_distribution.png")


def main():
    parser = argparse.ArgumentParser(
        description='Plot MPI scaling data for GAA Nanowire FET simulator')
    parser.add_argument('--input', '-i', default='scaling_data.csv',
                        help='Input CSV file (default: scaling_data.csv)')
    parser.add_argument('--output', '-o', default='scaling_plots',
                        help='Output directory for plots (default: scaling_plots)')
    args = parser.parse_args()

    if not os.path.exists(args.input):
        print(f"ERROR: File '{args.input}' not found.")
        print("Run the simulation first with different core counts.")
        print("The timer (QDSimTimer) will generate scaling_data.csv automatically.")
        sys.exit(1)

    print(f"Reading scaling data from: {args.input}")
    nprocs_list, phases, data = read_scaling_data(args.input)
    speedup, efficiency = compute_scaling_metrics(nprocs_list, data)

    # Always print text summary
    print_text_summary(nprocs_list, phases, data, speedup, efficiency)

    # Generate plots if matplotlib is available
    if HAS_MATPLOTLIB:
        plot_scaling(nprocs_list, phases, data, speedup, efficiency, args.output)
    else:
        print("Install matplotlib for graphical plots: pip install matplotlib")


if __name__ == '__main__':
    main()
